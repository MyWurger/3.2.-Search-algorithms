#include <iostream>     // стандартные потоки ввода/вывода
#include <fstream>      // файловые потоки ввода/вывода
#include <iomanip>      // библиотека с модификатором setw
#include <time.h>       // библиотека с модификатором srand
#include <chrono>       // подключение библиотеки для вычисления времени работы алгоритмов
#include "Functions.h"  // подключаем заголовочный файл с прототипами вспомогательных функций 
#include "Constant.h"   // подключаем заголовочный файл с глобальными константами
#include "Algorithms.h" // подключаем заголовочный файл с прототипами алгоритмов поиска
using namespace std;    // используем пространство имён std
/***************************************************/
/*             РЕАЛИЗАЦИЯ ФУНКЦИЙ                  */
/***************************************************/

/*-----------------------------------------------------------*/
/* печать условий для выбора функции */
/*-----------------------------------*/
void pechatusloviy()
{
	// Выводим условия в таблице
	setlocale(0, "C");                       // отключаем русский язык
	cout << char(218) << setw(40) << setfill((char)196) << (char)191 << endl << (char)179;  // выводим верхнюю строку шапки
	setlocale(LC_ALL, "Rus");                // подключаем русский язык
	cout << "   Выберите алгоритм поиска:           ";
	setlocale(0, "C");                       // отключаем русский язык
	cout << (char)179 << endl << (char)195 << setw(40) << (char)180 << setfill(' ') << endl << (char)179; // выводим нижнюю строку шапки
	cout << "  1. Better_Linear_search              ";                                                    // выводим условия выбора и нижнюю с боковыми строчками таблицы
	cout << (char)179 << endl << (char)195 << setw(40) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  2. Sentinel_Linear                   ";
	cout << (char)179 << endl << (char)195 << setw(40) << (char)180 << setfill(' ') << endl << (char)179;
	cout << "  3. T-sequential search               ";
	cout << (char)179 << endl << (char)195 << setw(40) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  4. Binary Search                     ";
	cout << (char)179 << endl << (char)195 << setw(40) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  5. Exit.                             ";
	cout << (char)179 << endl << (char)195 << setw(40) << (char)180 << setfill(' ') << endl;
	setlocale(LC_ALL, "Rus");                // подключаем русский язык
	return;                                  // возвращаем обещанное значение
}// pechatusloviy()


/*-----------------------------------------------------------*/
/* печать сформированного массива в таблице */
/*------------------------------------------*/
void pechat_tabl(int* pznachenue  // указатель на первый элемент динамического вектора 
	, int number)      // количество элементов в векторе
{
	int j;                        // для прохода по элементам массива
	cout << "\t\t\t\t Ц Е Л О Ч И С Л Е Н Н Ы Й   М А С С И В   З Н А Ч Е Н И Й: \n";
	setlocale(0, "C");            // выводим массив в красивых скобках
	cout << (char)218 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)191;          // вывод верхних квадратных скобок
	for (j = 0; j < number; j++)  // идем по всем элементам массива, используя адресную арифметику
	{
		cout << "\n" << char(179) << setw(17) << setfill(' ') << *(pznachenue + j) << setw(17) << setfill(' ') << char(179) << setw(6) << setfill(' ') << "n = " << j + 1;
	}// for j
	cout << '\n';
	cout << (char)192 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)217 << endl;  // вывод нижних квадратных скобок
	setlocale(LC_ALL, "Rus");     // подключаем русский язык
}//pechat_tabl()


/*-----------------------------------------------------------*/
/* создание динамического массива           */
/*------------------------------------------*/
void sozdanie(int** pznachenue    // адрес указателя на динамический вектор, для изменения значения указателя 
	, int& number                 // количество элементов в векторе для изменения
	, int vubor)                  // функция, выбранная пользователем, т.к для TS нужен массив number+1 элементов
{
	cout << "Введите количество элементов массива, большее " << kol_vo_min << " элементов: ";
	cin >> number;                // размер массива, введённый пользователем
	cout << "Вы ввели : " << number << endl;  // эхо-печать
	// если пользователь выбрал TS, то нужно создать массив размером number+1; причём на последнем месте стоит заведомо больший элемент, чем ключ
	if (vubor == 3)
	{
		*pznachenue = new int[number + 1];      // создали массив размером на 1 больше
		*(*pznachenue + number) = INT_MAX;      // на последнее место положили самое наибольшее, чем ключ чисел
		return;                               // создали - вышли. Вернули обещанное значение
	}// if vubor

	*pznachenue = new int[number];            // для всех остальных алгоритмов создали массив на нужное количество элементов
	return;                                   // создали - вышли. Вернули обещанное значение
}//sozdanie()


// заполнение динамическго массива - вектора
void zapolnenie(int* pznachenue   // указатель на первый элемент динамического вектора 
	, int number                  // количество элементов в векторе
	, int& search)                // ключ поиска для ввода пользователем
{
	int i;                        // для цикла заполнения
	int kol_vo_big = 0;           // для сохранения случайного значения количества чисел, больших ключа
	char choice;                  // выбор, где будет находиться ключ

	srand(time(NULL));            // базовое значение генератора псевдослучайных чисел, чтобы rand выдавал не одно и то же значение при разных вызовах
	cout << "В какой части массива Вы хотите, чтобы был ключ? Выберете из предложенных:\n\n";
	cout << setw(25) << setfill(' ') << "A) В начале массива;" << setw(30) << setfill(' ') << "B) В середине массива;" << setw(25) << setfill(' ') << "C) В конце массива;" << setw(35) << setfill(' ') << "D) Элемента нет в массиве;" << endl << endl;
	cout << "Введите A, B, C или D (Латиницей заглавными буквами): ";
	cin >> choice;               // пользователь выбрал, где будет находиться ключ
	cout << "Вы ввели: " << choice << endl << endl;  // эхо-печать
	cout << "Какое целое число будете искать? Введите целое число: ";  // чтобы в массиве два раза не попался ключ поиска
	cin >> search;               // ввод ключа поиска                     
	cout << "Вы ввели: " << search << endl << endl;  // эхо -печать

	if (!cin.good())              // если ключ поиска не число
	{// выход по ошибке
		cout << "Выбранный элемент поиска не является целым числом или вне диапазона!!!";
		udalenie(pznachenue);                      // удалили ранее созданный массив         
		cout << "\n\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
		system("pause");
		exit(1);                                   // закончили программу из функции
	}// if!(search < small && search >= 100)
	if (number > kol_vo_min)                       // количество больших столько, чтобы в массиве было два маленьких и ключ, но при этом больше 0
	{
		kol_vo_big = rand() % (number - kol_vo_min); // остальное количество элементов можно заполнить большими числами. Вычисление их количесва в случайном диапазоне.
	}
	else                                           // не хватает элементов в массиве для выполнения условий выше
	{
		cout << "Введите массив минимум " << kol_vo_min + 1 << " элемента!!!\n\n";
		udalenie(pznachenue);                      // удалили ранее созданный массив
		cout << "\n\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
		system("pause");
		exit(1);                                   // закончили программу из функции
	}
	// Выбор места, куда поставить в массиве ключ поиска
	if (choice == 'A')                             // в начало
	{
		pznachenue[0] = search;                    // поместили ключ в начало
		for (i = 1; i <= kol_vo_big; i++)          // заполняем места сначала числами, большими ключа
		{
			pznachenue[i] = random(search);        // вызвали функцию, передали значение, от которого будем отталкиваться
		}//for i
		for (i = kol_vo_big + 1; i < number; i++)    // оставшиеся места заполняем числами, большими ключа поиска
		{
			pznachenue[i] = rand() % (search - 1);   // заполнили случайными числами меньшими ключа
		}// for i
		return;                                    // заполнили - вернулись в caller
	}// if (choice == 'A') 

	if (choice == 'B')                             // в середину
	{
		for (i = 0; i <= kol_vo_big; i++)          // заполняем значала элементами, меньшими ключа поиска
		{
			pznachenue[i] = rand() % (search - 1);   // генерация случайных элементов, меньших ключа поиска
		}// for i
		for (i = kol_vo_big + 1; i < number; i++)    // оставшуюся часть заполняем элементами, большими ключа поиска 
		{
			pznachenue[i] = random(search);        // вызвали функцию, передали значение, от которого будем отталкиваться
		}// for i 
		pznachenue[number / 2] = search;           // в середину массива поместили ключ поиска
		return;                                    // заполнили - вернулись в caller
	}// if (choice == 'B')

	if (choice == 'C')                             // в конец массива
	{
		for (i = 0; i <= kol_vo_big; i++)          // заполняем значала элементами, меньшими ключа поиска
		{
			pznachenue[i] = rand() % (search - 1);   // генерация случайных элементов, меньших ключа поиска
		}// for i

		for (i = kol_vo_big + 1; i < number - 1; i++)// оставшуюся часть заполняем элементами, большими ключа поиска
		{
			pznachenue[i] = random(search);        // вызвали функцию, передали значение, от которого будем отталкиваться
		}// for i
		pznachenue[number - 1] = search;           // в конец поместили ключ поиска
		return;                                    // заполнили - вернулись в caller
	}//if (choice == 'C')

	if (choice == 'D')                             // в массиве нет ключа поиска
	{
		for (i = 0; i < number; i++)               // заполняем все элементы массива
		{
			pznachenue[i] = rand() % (search - 1);   // случайными числами, меньшими, чем ключ
		}// for i
		return;                                    // заполнили - вернулись в caller
	}//if (choice == 'D')
	// не попали ни на отдно из условий выбора ---> ошибка ввода
	cout << "\t\t\t\nВы ввели символ вне диапазона выбора, когда выбирали часть массива, где будет находиться ключ!!!\n";
	udalenie(pznachenue);                          // удалили ранее созданный массив 
	cout << "\n\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
	system("pause");
	exit(1);                                       // закончили программу из функции
}// zapolnenie()


/*-----------------------------------------------------------*/
/* формирование случайных чисел, больших ключа           */
/*-------------------------------------------------------*/
int random(int search)                             // передаём ключ, чтобы сформировать большие него элементы массива
{
	return((search + 1) + rand() % big);              // вернули число, большее ключа хотя бы на 1
}// random()


/*-----------------------------------------------------------*/
/* сортировка динамического массива           */
/*--------------------------------------------*/
void sort(int* pznachenue             // указатель на первый элемент динамического вектора
	, int number)                 // длина динамического вектора
{
	int Min;                                 // минимальный элемент
	int jMin;                                // индекс минимального элемента
	int iSort;                               // граница отсортированной области
	int i, j;                                // счётчики
	int Temp;                                // для обмена

	for (iSort = 0; iSort < number - 1; iSort++)   // пока не дошли до конца
	{
		// первый элемент из неупорядоченных назначаем минимальным. С УЧЁТОМ ПЕРЕДАЧИ АДРЕСА на первый элемент в функцию
		Min = *(pznachenue + iSort);               // мимнимум
		jMin = iSort;                              // его индекс

		// ищем минимальный элемент в оставшейся части массива
		for (j = iSort + 1; j < number; j++)
		{
			if (*(pznachenue + j) < Min)           // очередной кандидат на минимальный
			{
				// запоминаем минимальный элемент и его номер
				Min = *(pznachenue + j);
				jMin = j;
			}// if
		}// for j

		// нашли минимум в неупорядоченной части массива
		// ставим его на место первого в неупорядоченной части массива
		// меняем элементы местами
		Temp = *(pznachenue + iSort);
		*(pznachenue + iSort) = *(pznachenue + jMin);
		*(pznachenue + jMin) = Temp;

		//cout << "\n/2:\t";  // контрольная печать
		//for (int i = 0; i < lenVec; i++)
		//{
		//	cout << pznachenue[i] << "\t";
		//}//for i
		//		cout << "\n";
	}// for iSort
	return;                                        // вернули обещанное значение
}// sort()


/*-----------------------------------------------------------*/
/* удаление динамического массива           */
/*------------------------------------------*/
void udalenie(int* pznachenue)                     // указатель на первый элемент динамического вектора
{
	delete[] pznachenue;                           // удалили динамический вектор
	return;                                        // возвращаем обещанное значение
}// udalenie()


/*-----------------------------------------------------------*/
/* выбор функции из массива                 */
/*------------------------------------------*/
int(*MENU(int& vubor              // функция, выбранная пользователем
	, int pechat))                // выбор, печатать ли подробно сравнения в массиве при поиске
	(int*, int, int)              // спецификация параметров функции
{
	string name[5] = { "Better_Linear_search", "Sentinel_Linear", "T-sequential search", "Binary Search", "Exit." };   // массив названий алгоритмов поиска для печати названия выбранного алгоритма на экран
	int (*functions[])(int*, int, int) = { BLS, SLS, TS, BS };                                                         // массив указателей на чистые функции, соответствующий их типам и типам их параметров
	int (*functions_podr[])(int*, int, int) = { BLS_search, SLS_search, TS_search, BS_search };                        // массив указателей на утяжеленные выводами функции, соответствующий их типам и типам их параметров
	cout << "\nВыберете функцию: 1 - 5, где 5 - выход \n";
	cout << "Вы ввели: ";
	cin >> vubor;                                // ввод выбора алгоритма поиска пользователем
	if ((vubor > 0) && (vubor < 5))              // если попали в диапазон номеров из таблицы
	{
		cout << "\t\t\t\t\t\t\x1b[32mА Л Г О Р И Т М   " << name[vubor - 1] << "\x1b[30m" << endl << endl;           // выводим название алгоритма из массива
		// пользователь не хочет выводить подробно все сравнения
		if (pechat == 'N')
		{
			return (functions[vubor - 1]);       // вывели соответствующий указатель из массива, содержащего указатели на чистые функции
		}// (pechat == 'N')

		// если пользователь хочет вывести все сравнения и поромежуточные действия
		else if (pechat == 'Y')
		{
			return (functions_podr[vubor - 1]); // вывели соответствующий указатель из массива, содержащего указатели на утяжелённые функции
		}// else if (pechat == 'Y')
	}
	else // пользователь ввёл число вне диапазона функций из таблицы или ввёл EXIT
	{
		return NULL;              // нулевой указатель - сбой работы
	}// if((vubor > 0) && (vubor < 5))
}// *MENU()


/*----------------------------------------------------------------------------------*/
/*  печать выбранного алгоритма сортировки на экран и в файл*/
/*----------------------------------------------------------*/
void pechat_mass_search(int* pznachenue      // указатель на первый элемент динамического вектора
	, int  number                            // количество элементов в векторе
	, int search)                            // ключ поиска, введённый пользователем. Для передачи в другие функции               
{
	char pechat;                             // выбор пользователя: хочет ли он вывести сравнения
	int res;                                 // результат поиска
	int vubor = 0;                           // номер функции, выбранной пользователем
	int(*choiсe)(int*, int, int);            // указатель на функцию, выбранную пользователем
	string name[5] = { "Better_Linear_search", "Sentinel_Linear", "T-sequential search", "Binary Search", "Exit." }; // массив имен алгоритмов поиска для вывода в файл, чтобы не запутаться
	ofstream fout;                           // объявление объекта для потокового вывода данных в файл
	fout.open(FNAME, ios::_Nocreate);        // связываем обЪект с файлом. Открываем для чтения

	if (!fout.is_open())                     // файл не найден
	{
		cout << "Файла с таким именем нет. Невозможно осуществить запись\n";
		fout.close();                        // закрыть файл для записи
		system("pause");
		return;                              // возвращаем значение, соответствующее типу
	}// if(!fout.is_open())

	while (1)                                // бесконечный цикл выбора до момента пока пользователь не выберет Exit или не ошибётся.
	{
		cout << "\t\t\t\t\t \x1b[34mР А Б О Т А   С   А Л Г О Р И Т М А М И   П О И С К А\x1b[30m\n\n";
		pechatusloviy();                     // вывод функции печати условий
		cout << "\n\nХотите ли Вы вывести подробно все сравнения? Введите Y или N: ";
		cin >> pechat;                       // ввод, хочет ли пользователь вывести подробно все сравнения
		cout << "Вы ввели: " << pechat << endl;          // эхо-печать
		if (!((pechat == 'Y') || (pechat == 'N')) != 0)  // если он ввёл не тот символ
		{
			cout << "Выберите Y или N. Латиницей заглавными буквами\n";
			system("pause");
			system("cls");                               // для каждой новой функции чистим экран
			continue;                                    // запускаем выбор заново
		}// if(!((pechat == 'Y') || (pechat == 'N')) != 0)

		choiсe = MENU(vubor, pechat);                    // присваиваем указателю функцию из массива, выбранную пользователем
		if (choiсe == NULL)                              // если вышли за рамки диапазона допустимого или Exit
		{
			cout << "\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
			system("pause");
			break;                                       // закончили цикл
		}// if
		sozdanie(&pznachenue, number, vubor);            // создали динамический массив с регулируемым числом элементов
		zapolnenie(pznachenue, number, search);          // заполнили динамический массив
		pechat_tabl(pznachenue, number);                 // распечатали его в скобках

		if ((vubor == 3) || (vubor == 4))                // если пользователь выбрал функцию, где массив должен быть отсортирован
		{
			sort(pznachenue, number);                    //передаём number, т.к number+1-ый элемент всегда больше любого элемента массива. Он и так стоит на своём отсортированном месте - последнем
			cout << "\n\n\t\t\t\t\t\tО Т С О Р Т И Р О В А Н Н Ы Й \n\n";
			pechat_tabl(pznachenue, number);             // распечатали - проверили, отсортировался ли массив
		}// if((vubor == 3) || (vubor == 4))

		if (pechat == 'N')                               // если пользователь не хочет выводить подробно все сравнения
		{
			auto start = chrono::steady_clock::now();    // начали отсчитывать время работы, т.к. алгоритм чистый
			res = choiсe(pznachenue, number, search);    // вызвали функцию, выбранную из массива через указатель
			auto end = chrono::steady_clock::now();      // закончили отсчитывать время работы
			fout << "\t\t\t" << name[vubor - 1] << endl;  // выводим в файл имя выюранного алгоритма
			cout << "Время выполнения функции, формирующей алгоритм = " << chrono::duration_cast<chrono::nanoseconds>(end - start).count() << "  наносекунд; \n\n";             // выводим на экран время работы
			fout << "Время выполнения функции, формирующей алгоритм = " << chrono::duration_cast<chrono::nanoseconds>(end - start).count() << "  наносекунд; \n\n";             // выводим на экран время работы
		}
		else if (pechat == 'Y')                          // если пользователь  хочет выводить подробно все сравнения    
		{
			res = choiсe(pznachenue, number, search);    // вызвали функцию, выбранную из массива через указатель
		}// if
		// если элемент нашли в массиве
		if (res != -1)
		{
			cout << "\nНомер элемента, который нашли в массиве : " << res + 1 << endl;   // вывели его индекс
			cout << "Сам элемент: " << pznachenue[res] << endl;                          // вывели сам элемент
		}
		// если элемент не нашли в массиве
		else
		{
			cout << "Данного элемента в массиве нет, попробуйте другой.\n\n";
		}// if (res != -1)
		system("pause");
		system("cls");                                                      // для каждой новой функции чистим экран
		udalenie(pznachenue);                                               // для каждой новой функции создаём динамический ветор заново
	}// while
	fout.close();
	return;                                                                 // возвращаем обещанное значение
}// pechat_mass()