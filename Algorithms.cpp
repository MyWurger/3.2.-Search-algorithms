#include"algorithms.h"  // подключаем заголовочный файл с прототипами алгоритмов поиска
#include <iostream>     // стандартные потоки ввода/вывода
using namespace std;
/*-----------------------------------------------------------*/
/* Better_Linear_search                     */
/*------------------------------------------*/
int BLS(int* pznachenue           // указатель на первый элемент динамического вектора
	, int number                  // длина динамического вектора
	, int search)                 // ключ поиска, введённый пользователем
{
	int i;                        // для цикла
	for (i = 0; i < number; i++)  // проходим все элементы до последнего
	{
		if (pznachenue[i] == search) // если текущий элемент равен ключу поиска
		{
			return i;                // вернули его индекс
		}// if(pznachenue[i] == search)
	}// for 
	return (-1);                  // прошли по всему массиву - ничего не нашли
}// BLS()


/*-----------------------------------------------------------*/
/* Sentinel_Linear_ search                  */
/*------------------------------------------*/
int SLS(int* pznachenue           // указатель на первый элемент динамического вектора
	, int number                  // длина динамического вектора
	, int search)                 // ключ поиска, введённый пользователем
{
	int i = 0;                    // для цикла
	int last = pznachenue[number - 1];  // сохраняем последний элемент массива
	pznachenue[number - 1] = search;    // ставим на его места ключ (избавляемся от проверки на выход за пределы количества элементов массива)
	// пока текущий элемент массива - не ключ. Цикл закончится в любом случае, т.к хотя бы на последнем месте есть ключ
	while (pznachenue[i] != search)
	{
		i = i + 1;                      // увеличиваем индексы
	}// while
	pznachenue[number - 1] = last;      // помещаем последний элемент обратно на его место
	// если нашли ключ до последнего элемента массива или сам последний есть ключ
	if ((i < number - 1) || (pznachenue[number - 1] == search))
	{
		return(i);                      // возвращаем индекс ключа в массиве
	}// if
	return (-1);                        // прошли по всему массиву - ничего не нашли
}// SLS()


/*-----------------------------------------------------------*/
/* T-sequential search                      */
/*------------------------------------------*/
int TS(int* pznachenue            // указатель на первый элемент динамического вектора
	, int number                  // длина динамического вектора
	, int search)                 // ключ поиска, введённый пользователем
{
	int i = 0;                    // для прохода по индексам массива
	while (true)                  // пока не нашли больший элемент (цикл не будет бесконечным, т.к на последнем месте массива у нас всегда самое большое число)
	{
		if (search <= pznachenue[i])      // если ключ меньше/равен текущему элементу массива (пропустили все меньшие ключа элементы)
		{
			if (search == pznachenue[i]) // если ключ равен текущему элементу массива
			{
				return(i);               // вернуть индекс текущего элемента
			}//	if (search == pznachenue[i])	
			return(-1);                  // ничего не нашли, т.к дальше в массиве пойдут все элементы, большие ключа
		}// if (search <=pznachenue[i])
		i = i + 1;                // переходим к следующему элементу
	}// while
}// TS()


/*-----------------------------------------------------------*/
/* Binary Search                            */
/*------------------------------------------*/
int BS(int* pznachenue            // указатель на первый элемент динамического вектора
	, int number                  // длина динамического вектора
	, int search)                 // ключ поиска, введённый пользователем
{
	int p = 0;                    // левый конец рассматриваемой части массива
	int r = number - 1;           // правый конец рассматриваемой части массива
	int q;                        // серединное значение рассматриваемой массива
	// пока массив не схлопнулся
	while (p <= r)
	{
		q = (p + r) / 2;          // вычисляем медиану массива
		if (pznachenue[q] == search)     // если элемент медианы массива равен ключу поиска
		{
			return(q);                   // вернуть индекс ключа поиска (медианы)
		}
		else if (pznachenue[q] > search) // если элемент медианы массива больше ключа поиска
		{
			r = q - 1;                   // смещаем правую границу до него, т.к не имеет смысла рассматривать большие элементы
		}
		else                             // если элемент медианы массива меньше ключа поиска
		{
			p = q + 1;                   // смещаем левую границу после него, т.к не имеет смысла рассматривать меньшие элементы
		}// if
	}// while
	return(-1);                          //(p>r) массив схлопнулся. Ничего не нашли.
}// BS()


/*-----------------------------------------------------------*/
/* подробный Better_Linear_search           */
/*------------------------------------------*/
int BLS_search(int* pznachenue    // указатель на первый элемент динамического вектора
	, int number                  // длина динамического вектора
	, int search)                 // ключ поиска, введённый пользователем
{
	int sravnenie = 0;            // считаем количество сравнений
	int i;                        // для цикла
	cout << "Сравнивающиеся пары : \n";
	cout << "\t\t";
	for (i = 0; i < number; i++)  // проходим все элементы до последнего
	{
		// увеличиваем количество сравнений
		sravnenie = sravnenie + 1;
		if (pznachenue[i] == search)     // если текущий элемент равен ключу поиска
		{
			cout << "\x1b[31m{" << pznachenue[i] << " ~ " << search << "} --> элемент нашли\x1b[30m ";  // выводим последнее сравнение
			cout << "\n\nКоличество проведённых сравнений: " << sravnenie << endl;                      // вывели количество сравнений
			return i;             // вернули его индекс      
		}// if(pznachenue[i] == search)
		cout << "{" << pznachenue[i] << " ~ " << search << "}, "; // выводим пары элементы сравнений

		// для вывода перехода на новую строку между парами сравне сравнивающихся элементов
		if (i % 5 == 0 && i != 0)
		{
			cout << endl;
			cout << "\t\t";
		}//if (i % 5 == 0 && i != 0)
	}// for
	cout << "\nКоличество проведённых сравнений: " << sravnenie << endl; // вывод количества сравнений, если не нашли ключ поиска в массиве
	return (-1);                  // прошли по всему массиву - ничего не нашли
}//BLS_search()


/*-----------------------------------------------------------*/
/* подробный Sentinel_Linear_ search        */
/*------------------------------------------*/
int SLS_search(int* pznachenue    // указатель на первый элемент динамического вектора
	, int number                  // длина динамического вектора
	, int search)                 // ключ поиска, введённый пользователем
{
	int sravnenie = 0;            // количество сравнений
	int i = 0;                    // для цикла
	int last = pznachenue[number - 1];  // сохраняем последний элемент массива
	cout << "Сравнивающиеся пары : \n";
	cout << "\t\t";
	pznachenue[number - 1] = search;    // ставим на его места ключ (избавляемся от проверки 
	// пока текущий элемент массива - не ключ. Цикл закончится в любом случае, т.к хотя бы на последнем месте есть ключ
	while (pznachenue[i] != search)
	{
		cout << "{" << pznachenue[i] << " ~ " << search << "}, ";        // выводим пары элементы сравнений
		// для вывода перехода на новую строку между парами сравне сравнивающихся элементов
		if (i % 5 == 0 && i != 0)
		{
			cout << endl;
			cout << "\t\t";
		}// if i
		sravnenie = sravnenie + 1; // увеличели количество сравнений, не последнее сравнение
		i = i + 1;                 // увеличиваем индексы
	}// while
	pznachenue[number - 1] = last; // помещаем последний элемент обратно на его место
	// если нашли ключ до последнего элемента массива или сам последний есть ключ
	if ((i < number - 1) || (pznachenue[number - 1] == search))
	{
		sravnenie = sravnenie + 1; // учли последнее сравнение, если выполнениы условия
		cout << "\x1b[31m{" << pznachenue[i] << " ~ " << search << "} --> элемент нашли\x1b[30m ";      // выводим последнее сравнение
		cout << "\n\nКоличество проведённых сравнений: " << sravnenie << endl;                          // выводим количество сравнений, если нашли ключ
		return(i);                 // возвращаем индекс ключа в массиве
	}// if i
	sravnenie = sravnenie + 1;     // учли последнее сравнение, если не выполнениы условия
	cout << "\nКоличество проведённых сравнений: " << sravnenie << endl;                                // выводим количество сравнений, если не нашли ключ
	return (-1);                   // прошли по всему массиву - ничего не нашли
}// SLS_search()


/*-----------------------------------------------------------*/
/*  подробный T-sequential search           */
/*------------------------------------------*/
int TS_search(int* pznachenue     // указатель на первый элемент динамического вектора
	, int number                  // длина динамического вектора
	, int search)                 // ключ поиска, введённый пользователем
{
	int i = 0;                    // для прохода по индексам массива
	int sravnenie = 0;            // количество сравнений
	cout << "Элементы отсортированного массива, находящиеся до ключа: \n";
	while (true)                  // пока не нашли больший элемент (цикл не будет бесконечным, т.к на последнем месте массива у нас всегда самое большое число)
	{
		sravnenie = sravnenie + 1;// увеличили количество сравнений
		if (search <= pznachenue[i])      // если ключ меньше/равен текущему элементу массива (пропустили все меньшие ключа элементы)
		{
			if (search == pznachenue[i])  // если ключ равен текущему элементу массива
			{
				cout << "\nПоследний элемент массива: \x1b[31m{" << pznachenue[number] << "}\x1b[30m \n\n";   // Если нашли ключ. выводим последний элемент массива, чтобы показать, что он есть
				cout << "Количество проведённых сравнений в отсортированном массиве: " << sravnenie << endl;  // выводим количество сравнений, если нашли ключ
				return(i);
			}//	if (search == pznachenue[i])
			cout << "\nПоследний элемент массива: \x1b[31m{" << pznachenue[number] << "}\x1b[30m \n\n";       // Если не нашли ключ. выводим последний элемент массива, чтобы показать, что он есть
			cout << "Количество проведённых сравнений в отсортированном массиве: " << sravnenie << endl;      // выводим количество сравнений, если не нашли ключ
			return(-1);
		}// if (search <=pznachenue[i])
		cout << pznachenue[i] << ", ";   // выводим элементы массива, находящиеся до ключа
		i = i + 1;               // переходим к следующему элементу
	}// while
}// TS_search()


/*-----------------------------------------------------------*/
/*  подробный Binary Search                 */
/*------------------------------------------*/
int BS_search(int* pznachenue     // указатель на первый элемент динамического вектора
	, int number                  // длина динамического вектора
	, int search)                 // ключ поиска, введённый пользователем
{
	int p = 0;                    // левый конец рассматриваемой части массива
	int r = number - 1;           // правый конец рассматриваемой части массива
	int q;                        // серединное значение рассматриваемой массива
	int i;                        // для вывода рассматриваемых частей массива
	int sravnenie = 0;            // количество сравнений
	cout << "Уменьшение диапазова рассматриваемых элементов по действиям: \n";
	// пока массив не схлопнулся
	while (p <= r)
	{
		cout << "[ ";
		for (i = p; i <= r; i++)  // выводим элементы в рассматриваемой части массива в строку
		{
			cout << pznachenue[i];
			if (i != r)           // не выводим запятую после последнего элемента 
			{
				cout << ", ";
			}// if i
		}// for i
		cout << " ] ";
		q = (p + r) / 2;          // вычисляем медиану массива
		cout << "  q = " << q;    // выводим значение медианы
		cout << "   {" << pznachenue[q] << " ~ " << search << "} \n"; // выводим сравнение медианного элемента с ключом поиска
		sravnenie = sravnenie + 1;// увеличили количество сравнений ключа с элементом медианы
		// если элемент медианы массива равен ключу поиска
		if (pznachenue[q] == search)
		{
			cout << "\x1b[31m{" << pznachenue[q] << " ~ " << search << "} --> элемент нашли\x1b[30m \n";  // вывели ещё раз и подчеркнули это сравнение
			cout << "Количество проведённых сравнений в отсортированном массиве: " << sravnenie << endl;  // вывели количество сравнений ключа поиска с медианой, если нашли элемент
			return(q);            // вернуть индекс ключа поиска (медиан)
		}
		// если элемент медианы массива больше ключа поиска
		else if (pznachenue[q] > search)
		{
			r = q - 1;            // смещаем правую границу до него, т.к не имеет смысла рассматривать большие элементы
		}
		// если элемент медианы массива меньше ключа поиска
		else
		{
			p = q + 1;            // смещаем левую границу после него, т.к не имеет смысла рассматривать меньшие элементы
		}// if
	}// while
	cout << "Количество проведённых сравнений в отсортированном массиве: " << sravnenie << endl;         // вывели количество сравнений ключа поиска с медианой, если не нашли элемент
	return(-1);                   //(p>r) массив схлопнулся. Ничего не нашли.
}//BS_search()